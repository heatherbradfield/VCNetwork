import java.util.*;/** * A class that creates a minimum spanning tree * for a given graph * The graph is represented by adjacency matrix * * @author Anna Bieszczad * @version 11/21/2015 *///Heather Bradfieldpublic class MinimumSpanningTree{    // The matrix below represents the graph from the example provided in the lab description    // The instructor used this hardcoded matrix for testing,    // your code however must generate the matrix randomly//    private int[][] adjMatrix = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},//                                 {0, 0, 0, 3, 1, 0, 0, 0, 0, 0, 2},//                                 {0, 0, 0, 4, 0, 0, 10, 0, 0, 0, 0},//                                 {0, 3, 4, 0, 3, 5, 0, 0, 0, 0, 0},//                                 {0, 1, 0, 3, 0, 2, 0, 0, 0, 0, 0},//                                 {0, 0, 0, 5, 2, 0, 6, 0, 1, 0, 0},//                                 {0, 0, 10, 0, 0, 6, 0, 9, 10, 0, 0},//                                 {0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0},//                                 {0, 0, 0, 0, 0, 1, 10, 0, 0, 8, 0},//                                 {0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 10},//                                 {0, 2, 0, 0, 0, 0, 0, 0, 0, 10, 0}};    private int[][] adjMatrix;    private int[][] minimumSpanningTree;    private int numberOfNodes;    final int GRAYED_OUT = -1;    final int MARKED_FOR_CHECKING = -1;    final int PERCENT100 = 100;    public MinimumSpanningTree(int numberOfNodes, int probability)    {        this.numberOfNodes = numberOfNodes;        this.adjMatrix = new int [this.numberOfNodes+1][this.numberOfNodes+1];        this.minimumSpanningTree = new int [this.numberOfNodes+1][this.numberOfNodes+1];        Random rand = new Random();        for (int r = 1; r <= this.numberOfNodes; r++)        {            for (int c = 1; c <= this.numberOfNodes; c++)            {                if (c > r && probability > rand.nextInt(PERCENT100))                {                    this.adjMatrix[r][c] = rand.nextInt(this.numberOfNodes) + 1;                    this.adjMatrix[c][r] = this.adjMatrix[r][c];                }            }        }    }    public boolean isConnected()    {        boolean connected = true;        for (int r = 1; r <= this.numberOfNodes && connected; r++)        {            connected = false;            for (int c = 1; c <= this.numberOfNodes && !connected; c++)            {                if (this.adjMatrix[r][c] != 0)                {                    connected = true;                }            }        }        return connected;    }    public void calculateMinimumSpanningTree()    {        this.adjMatrix[0][1] = GRAYED_OUT;        this.adjMatrix[1][0] = MARKED_FOR_CHECKING;        int grayedOut = 1;        Element elem;        while (grayedOut < this.numberOfNodes)        {            elem = findSmallestInMarkedRows();            this.minimumSpanningTree[elem.row][elem.column] = elem.value;            this.minimumSpanningTree[elem.column][elem.row] = elem.value;            this.adjMatrix[0][elem.column] = GRAYED_OUT;            this.adjMatrix[elem.column][0] = MARKED_FOR_CHECKING;            grayedOut++;        }    }    private Element findSmallestInMarkedRows()    {        int smallest = this.numberOfNodes;        int row = 0;        int col = 0;        for (int r = 1; r <= this.numberOfNodes; r++)        {            if (this.adjMatrix[r][0] == MARKED_FOR_CHECKING)            {                for (int c = 1; c <= this.numberOfNodes; c++)                {                    if (this.adjMatrix[0][c] != GRAYED_OUT &&                            this.adjMatrix[r][c] < smallest &&                            this.adjMatrix[r][c] > 0)                    {                        row = r;                        col = c;                        smallest = this.adjMatrix[row][col];                    }                }            }        }        //System.out.println("row= " + row + "; col= " + col + "; smallest= " + smallest);        return new Element(row, col, smallest);    }    public void displayGraph()    {        System.out.println("***** GENERATED GRAPH *****");        displayMatrix(this.adjMatrix);    }    public void displayMinimumSpanningTree()    {        System.out.println("\n\n***** MINIMUM SPANNING TREE FOR THE ABOVE GRAPH *****");        displayMatrix(this.minimumSpanningTree);    }    private void displayMatrix(int[][] matrix)    {        System.out.print("     ");        for (int c = 1; c <= this.numberOfNodes; c++)        {            System.out.printf("[%1$2d]", c);        }        System.out.println();        for (int r = 1; r <= this.numberOfNodes; r++)        {            //System.out.print(r + " ");            System.out.printf("[%1$2d]", r);            for (int c = 1; c <= this.numberOfNodes; c++)            {                if (matrix[r][c] > 0)                    System.out.printf("%1$4d", matrix[r][c]);                else                    System.out.printf("%1$4s", " ");            }            System.out.println();        }    }    public static void main(String[] args)    {        System.out.println("How many nodes in your graph?");        Scanner scan = new Scanner(System.in);        int numberOfNodes = scan.nextInt();        System.out.println("Probability of edge? (type 70 for 70%)");        int probability = scan.nextInt();        MinimumSpanningTree graph = new MinimumSpanningTree(numberOfNodes, probability);        graph.displayGraph();        if (graph.isConnected())        {            graph.calculateMinimumSpanningTree();            graph.displayMinimumSpanningTree();        }        else            System.out.println("The graph is not connected, the minimum spanning tree will not be calculated");    } // end main    private class Element    {        private int row;        private int column;        private int value;        public Element(int row, int column, int value)        {            this.row = row;            this.column = column;            this.value = value;        }    }}